# Rendering Model

astrid offers a custom 2D graphics library for drawing various shapes and images. The core class for rendering content is the Drawable. The term drawable means that it is an object that can be added to a display surface and drawn to the screen. What it draws can be anything you want or you can use one of the many built-in Drawable subclasses.

A drawable is considered the lowest level of a visual object on the screen. Not only does a drawable render content, it also provides a mechanism for measurement, layout, property changes, bitmap caching, effects, animations and more. It is probably the single most important part of the entire framework. Each drawable maintains its own graphics object and is responsible for determining whether it needs to be rendered during each frame cycle. The display surface itself is a drawable and not only can you render directly to a drawable via its graphics but you can combine multiple drawables together to build a composite drawable. You can consider a drawable as a collection of other drawables, as a single visual component, or both.

Drawables can also be cached to improve performance using a technique known as bitmap caching. When a drawable is set to cache itself as a bitmap it renders itself to an external (in-memory) <canvas /> element and is updated in the same way as non-cached drawables. However, the difference is that during each frame, a full render pass must occur, regardless if anything has changed or not, in most cases, we still perform all the drawing operations, while this is usually plenty fast enough for a drawable that is not within the currently computed clip region it still requires various checks, loops and calls into the native renderer. Bitmap caching solves this problem by simply blitting the entire contents of a drawable and skipping all recursion. This is helpful if you have a complex draw tree.

The rendering model of a drawable is deferred by the astrid framework, that is, when you draw to a drawables graphics object you are actually just sending a set of operations that need to be performed and are not drawing directly to the <canvas /> element in real time. This helps with performance as the native renderer (be that the Web Browser or a native astrid application) can make intelligent decisions on whether to batch commands and/or allow the GPU to cache various operations. Not only does this help with performance but it also allows us to perform additional tasks on the graphics operations submitted, for example, we use these operations to calculate the precise filled and stroked bounds of a drawable (this allows us to get accurate dirty regions), we also use these operations to perform line dashing (something not yet supported by the native canvas) as well as other various tasks.

If you don't implement the standard drawing model, that is, via the `layout` method, you must call either `invalidate` or `invalidateRegion` on the drawable to tell it that all or a portion of it's content has changed and needs to be updated. Rendering occurs using the "painters algorithm" that is, from back to front.
